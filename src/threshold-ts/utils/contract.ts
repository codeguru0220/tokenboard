import { JsonRpcSigner, Web3Provider, BlockTag } from "@ethersproject/providers"
import { Contract, ContractInterface, providers, Signer, Event } from "ethers"
import { getEvents } from "@keep-network/tbtc-v2.ts/dist/src/ethereum-helpers"
import { AddressZero, getAddress, isAddressZero } from "./address"
import { getEnvVariable } from "../../utils/getEnvVariable"

// account is not optional
export function getSigner(
  library: Web3Provider,
  account: string
): JsonRpcSigner {
  return library.getSigner(account).connectUnchecked()
}

// account is optional
export function getProviderOrSigner(
  library: Web3Provider,
  account?: string
): Web3Provider | JsonRpcSigner {
  return account ? getSigner(library, account) : library
}

export const getContract = (
  address: string,
  abi: ContractInterface,
  providerOrSigner: providers.Provider | Signer | undefined,
  account?: string
) => {
  if (!getAddress(address) || isAddressZero(address)) {
    throw Error(`Invalid 'address' parameter '${address}'.`)
  }
  return new Contract(
    address,
    abi,
    getProviderOrSigner(providerOrSigner as any, account) as any
  )
}

interface EventFilterOptions {
  fromBlock?: BlockTag
  toBlock?: BlockTag
  filterParams: any[]
  eventName: string
}

const GET_EVENTS_BLOCK_INTERVAL =
  getEnvVariable("GET_EVENTS_BLOCK_INTERVAL") ?? 10_000

export const getContractPastEvents = async (
  contract: Contract,
  options: EventFilterOptions
): Promise<Array<Event>> => {
  const filter = contract.filters[options.eventName](...options.filterParams)

  return await getEvents(
    contract,
    filter,
    options.fromBlock,
    options.toBlock,
    GET_EVENTS_BLOCK_INTERVAL
  )
}

export function getContractAddressFromTruffleArtifact(
  truffleArtifact: { networks: { [chainID: string]: { address: string } } },
  chainID: string | undefined = undefined
) {
  const networks = Object.keys(truffleArtifact.networks) as Array<
    keyof typeof truffleArtifact.networks
  >

  return networks && networks.length > 0
    ? (
        truffleArtifact.networks[chainID ? chainID : networks[0]] as {
          address: string
        }
      ).address
    : AddressZero
}
